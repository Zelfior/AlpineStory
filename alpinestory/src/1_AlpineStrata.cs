using System;
using Vintagestory.API.Common;
using Vintagestory.API.Datastructures;
using Vintagestory.API.Server;
using Vintagestory.ServerMods;
using System.Threading.Tasks;
using SkiaSharp;
using System.Linq;
using Vintagestory.API.Util;

public class AlpineStrata: ModStdWorldGen
{
    ICoreServerAPI api;
    int maxThreads;
    internal float data_width_per_pixel;        
    internal int max_height_custom;
    internal int min_height_custom; 
    internal UtilTool uTool;
    internal MapLayerCustomPerlin[] strataNoises;
    internal RockStrataConfig strata;
    internal int[] rockIds;
    public AlpineStrata(){}
    public AlpineStrata(ICoreServerAPI api, float data_width_per_pixel, int min_height_custom, UtilTool uTool)
    {
        /**
                This class will replace a layer of 10 blocks of another rock under the surface for a better gameplay experience.

                The block choice is made based on a perlin noise map associated to each rock type:
                    When the noise is greater than a threshold, the associated rock will replace the in place granite.

        */
        LoadGlobalConfig(api);
        
        this.api = api;

        maxThreads = Math.Min(Environment.ProcessorCount, api.Server.Config.HostedMode ? 4 : 10);

        max_height_custom = api.WorldManager.MapSizeY;
        this.data_width_per_pixel = data_width_per_pixel;
        this.min_height_custom = min_height_custom;

        this.uTool = uTool;
        
        IAsset asset = api.Assets.Get("worldgen/rockstrata.json");
        strata = asset.ToObject<RockStrataConfig>();

        LoadGlobalConfig(api);

        chunksize = api.WorldManager.ChunkSize;

        //  Storing the block id of different rock types.
        rockIds = new int[14];
        rockIds[0] = api.WorldManager.GetBlockId(new AssetLocation("rock-granite"));
        rockIds[1] = api.WorldManager.GetBlockId(new AssetLocation("rock-basalt"));
        rockIds[2] = api.WorldManager.GetBlockId(new AssetLocation("rock-andesite"));
        rockIds[3] = api.WorldManager.GetBlockId(new AssetLocation("rock-peridotite"));
        rockIds[4] = api.WorldManager.GetBlockId(new AssetLocation("rock-chalk"));
        rockIds[5] = api.WorldManager.GetBlockId(new AssetLocation("rock-claystone"));
        rockIds[6] = api.WorldManager.GetBlockId(new AssetLocation("rock-sandstone"));
        rockIds[7] = api.WorldManager.GetBlockId(new AssetLocation("rock-shale"));
        rockIds[8] = api.WorldManager.GetBlockId(new AssetLocation("rock-limestone"));
        rockIds[9] = api.WorldManager.GetBlockId(new AssetLocation("rock-conglomerate"));
        rockIds[10] = api.WorldManager.GetBlockId(new AssetLocation("rock-chert"));
        rockIds[11] = api.WorldManager.GetBlockId(new AssetLocation("rock-phyllite"));
        rockIds[12] = api.WorldManager.GetBlockId(new AssetLocation("rock-slate"));
        rockIds[13] = api.WorldManager.GetBlockId(new AssetLocation("rock-bauxite"));

        //  Instanciating the perlin noise maps that will be used for the strata choice
        strataNoises = new MapLayerCustomPerlin[strata.Variants.Length];
        for (int i = 0; i < strata.Variants.Length; i++)
        {
            strataNoises[i] = new MapLayerCustomPerlin(api.World.Seed + 23423 + 500*i, new double[] { 14, 0, 0, 0 }, new double[] { 1 / 100.0 / 5, 1 / 50.0 / 5, 1 / 25.0 / 5, 1 / 12.5 / 5 }, new double[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13});
        }
    }
    public override double ExecuteOrder()
    {
        return 0.13;
    }
    public void OnChunkColumnGen(IChunkColumnGenerateRequest request)
    {   
        generate(request.Chunks, request.ChunkX, request.ChunkZ, request.RequiresChunkBorderSmoothing);
    }
    private void generate(IServerChunk[] chunks, int chunkX, int chunkZ, bool requiresChunkBorderSmoothing)
    {
        //  The IntDataMap2D are 1D int containers that will store the noise map generated by the MapLayerCustomPerlin.
        //  It contains one value per X - Z coordinate.

        IntDataMap2D[] intmaps = new IntDataMap2D[strata.Variants.Length];
        
        for (int i = 0; i < strata.Variants.Length; i++)
        {
            intmaps[i] = new IntDataMap2D();
            intmaps[i].Data = strataNoises[i].GenLayer(
                chunkX*chunksize ,
                chunkZ*chunksize ,
                chunksize,
                chunksize
            );
        }

        /*
            Loading back the height map stored by AlpineTerrain
        */
        int[] maxHeights = SerializerUtil.Deserialize<int[]>(chunks[0].MapChunk.MapRegion.GetModdata("Alpine_HeightMap"));

        //  Setting the value of the rock in the chunks data.
        for (int lZ = 0; lZ < chunksize; lZ++)
        {
            for (int lX = 0; lX < chunksize; lX++)
            {
                int mapIndex = uTool.ChunkIndex2d(lX, lZ, chunksize);
                int maxHeight=maxHeights[mapIndex];

                for (int i = 1; i < strata.Variants.Length; i++)
                {
                    if(intmaps[i].Data[mapIndex]  > 8){
                        for (int j = 1; j < 15; j++)
                        {
                            if(maxHeight-j-5 > 0)
                            {
                                uTool.setBlockId(lX, maxHeight-j-5, lZ, chunksize, chunks, rockIds[i%14]);
                            }
                        }
                        for (int j = 15; j < 30; j++)
                        {
                            if(maxHeight-j-5 > 0)
                            {
                                uTool.setBlockId(lX, maxHeight-j-5, lZ, chunksize, chunks, rockIds[(i+5)%14]);
                            }
                        }
                        break;
                    }
                }
            }
        }
    }
}